---
alwaysApply: false
description: code quality guidelines
---

# Принципы качества кода и совместной работы

## Философия разработки

### "Понимание превыше скорости"
- Каждый кусок кода должен быть понятен через 6 месяцев.
- Всегда объясняйте "почему" (а не "что") в комментариях.
- Сложная логика сопровождается обязательными пояснениями.
- Лучше потратить время на объяснение сейчас, чем на рефакторинг потом.

### "Один паттерн — одно решение"
- Для каждой задачи используем единый паттерн по всему проекту.
- Запрещено изобретать новые способы для уже решённых задач.
- Все паттерны документируются и переиспользуются.

## Принципы модульной разработки

- Понятные имена функций и переменных.
- Docstrings для сложной логики и публичных методов.
- Комментарии объясняют "почему", а не "что".
- Примеры использования в docstrings.
- Каждый модуль оформляется по шаблону:
- Обязательны type hints
  ```
  ## Модуль: [Название]
  ### Что делает:
  - Краткое описание функциональности

  ### Как работает:
  - Основные компоненты и их взаимодействие
  - Ключевые алгоритмы и логика

  ### Интеграция:
  - С какими модулями взаимодействует
  - Какие зависимости использует
  - Как тестируется

  ### Примеры использования:
  - Конкретные сценарии работы
  - Входные и выходные данные
  ```

## Архитектурные принципы

- Вся работа с БД только через слой Repository.
- Прямые запросы к БД из сервисов или контроллеров запрещены.
- Для каждой модели — свой Repository-класс.
- Repository инкапсулирует всю логику доступа к данным.
- Используется базовый класс Repository для типовых операций.

## Борьба с дублированием кода

- Если логика повторяется 2+ раза — выносить в общий модуль.
- Общие компоненты размещаются в `app/common/`.
- Все паттерны и общие решения документируются в `docs/patterns.md`.
- Строгое следование принципу DRY на уровне модулей.

## Стандартизация ответов API

- Используется единый формат ответа (StandardResponse) для всех endpoint'ов.
- Все ошибки и сообщения возвращаются в стандартизированном виде.

## Принципы читаемости кода

- Обязательная типизация всех функций и переменных с неочевидным типом.
- Именование:
  - Функции: глагол + существительное (`create_user`)
  - Переменные: существительные (`user_data`)
  - Константы: UPPER_CASE (`MAX_RETRY_COUNT`)
  - Классы: PascalCase (`UserService`)
- Структура функций: валидация → бизнес-логика → возврат результата.
- Явная обработка ошибок с контекстом.

## Стандарты документации кода

- Docstrings для всех публичных функций, классов, API endpoint'ов и сложных алгоритмов.
- Формат docstring: описание, аргументы, возвращаемое значение, исключения, пример использования.

## Самопроверка кода

Перед коммитом убедитесь:
- Код соответствует паттернам и архитектуре проекта.
- Нет дублирования логики.
- Сложные функции имеют docstrings.
- Везде присутствует обработка ошибок.
- Тесты покрывают основные сценарии.
- Код будет понятен через 6 месяцев.

Вопросы для самопроверки:
1. Почему выбран именно этот подход?
2. Как этот код тестируется?
3. Что произойдет при ошибке?
4. Можно ли упростить логику?
5. Есть ли похожий код в проекте?

## Паттерны для переиспользования

- Для новых endpoint'ов, сервисов и репозиториев используйте стандартные шаблоны из документации.
- Все новые сервисы наследуются от BaseService.
- Все новые репозитории наследуются от BaseRepository.

## Принципы тестирования

- Тесты структурированы по классам и сценариям.
- Покрываются как успешные, так и ошибочные кейсы.
- Используются только реальные данные или тестовые окружения (никаких моков в продакшене).

## Принципы фронтенд-бэкенд интеграции

- Запрещено хардкодить моковые данные во фронтенде.
- Фронтенд всегда работает с реальным API.
- Моки разрешены только в тестах.
- Единые схемы данных между фронтом и бэком.
- Обработка всех состояний (loading, success, error) обязательна.

## Контрольные вопросы перед коммитом

- Могу ли я объяснить каждую строку кода?
- Есть ли похожий код в проекте?
- Все ли ошибки обрабатываются?
- Есть ли тесты для основных сценариев?
- Понятны ли имена переменных и функций?
- Есть ли документация для сложной логики?
- Нет ли хардкода моковых данных?
- Работает ли цепочка фронт-бэк-БД?

## Готовность модуля

- Модуль работает как задумано.
- Архитектурные решения понятны и задокументированы.
- Есть примеры использования.
- Модуль интегрирован с системой.
- Модуль работает с реальными данными.
